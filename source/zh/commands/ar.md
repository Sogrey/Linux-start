# ar - 建立或修改备存文件，或是从备存文件中抽取文件

ar命令 是一个建立或修改备存文件，或是从备存文件中抽取文件的工具，ar可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限.

ar指令可以创建、修改库，也可以从库中提取单个模块。库是一个单独的文件，里面包含了按照特定结构组织起来的其他文件，我们称作member。归档文件通常是一个二进制文件，我们一般将归档文件当作库来使用。原始文件的内容、模式(权限)、时间戳、所有者和组保存在存档中，并可在提取时恢复。

GNU ar可以维护其成员具有任意长度的名称的档案；但是，根据您的系统上对ar的配置方式，可以对成员名长度进行限制，以便与其他工具维护的存档格式兼容。如果存在，限制通常是15个字符(典型的与a.out相关的格式)或16个字符(典型的与coff相关的格式)。

当您指定修饰符的时候，ar会为存档中可重定位的对象模块中定义的符号创建一个索引。创建之后，每当ar对其内容进行更改时，这个索引就会在存档中更新(除了Q更新操作外)。具有这样一个索引的归档可以加速链接到库，并允许库中的例程相互调用，而不考虑它们在存档中的位置。您可以使用“nm -s”或“nm --print-armap”列出此索引表。如果存档缺少表，则可以使用另一种称为ranlib的ar形式来添加表。

GNU ar可以随意创建一个瘦存档，其中包含一个符号索引和对档案成员文件的原始副本的引用。这样的存档对于构建用于本地构建的库非常有用，因为在本地构建中，可重新定位的对象将保持可用，而复制每个对象的内容只会浪费时间和空间。薄档案也是扁平的，因此将一个或多个档案添加到一个瘦归档中将单独添加嵌套归档的元素。存档元素的路径是相对于归档本身存储的。

GNU Ar被设计成与两个不同的设施兼容。您可以使用命令行选项来控制它的活动，比如Unix系统上的不同类型的ar；或者，如果您指定了单一命令行选项-M，您可以使用标准输入提供的脚本来控制它，比如MRI "librarian"程序。


## 适用范围

<!-- <div class="svg linux">Linux</div> -->
<div class="svg redhat">RedHat</div>
<div class="svg rhel">RHEL</div>
<div class="svg ubuntu">Ubuntu</div>
<div class="svg centos">CentOS</div>
<div class="svg debian">Debian</div>
<div class="svg deepin">Deepin</div>
<div class="svg suse">SUSE</div>
<div class="svg opensuse">openSUSE</div>
<div class="svg fedora">Fedora</div>
<div class="svg linuxmint">Linux Mint</div>
<!-- <div class="svg mxlinux">MX Linux</div> -->
<div class="svg alpinelinux">Alpine Linux</div>
<div class="svg archlinux">Arch Linux</div>

## 语法

``` bash
ar   [--plugin name]   [-X32_64]   [-]p[mod  [relpos]  [count]]   archive   [member...]
```

## 选项
GNU ar允许您在第一个命令行参数中按任意顺序混合操作代码p和修饰符标志mod。如果您愿意，可以用“-”开始第一个命令行参数。p键字母指定要执行的操作；它可能是以下任一操作，但您必须仅指定其中一个操作：
``` bash
c  # 创建归档文件
d  # 删除归档中的成员文件，将要删除的模块的名称指定为member。如果没有指定要删除的文件，则存档将保持不变
m  # 改变成员文件在归档中的顺序 。如果在多个成员中定义了一个符号，则存档中成员的排序会改变程序使用库链接的方式。如果在“m”中没有使用修饰符，那么在成员参数中命名的任何成员都会移动到归档文件的末尾；您可以使用a、b或i修饰符将它们移动到指定的位置。
p  # 将存档的指定成员打印到标准输出文件。如果指定了v修饰符，请在将其内容复制到标准输出之前显示成员名。
q  # 将文件附加在归档文件的最后。修饰符a、b和i不影响此操作；新成员总是放在归档的末尾。修饰符v在追加时使每个文件都有ar列表。因为这个操作的重点是速度，所以存档的符号表索引不会更新，即使它已经存在；您可以显式地使用ar或ranlib来更新符号表索引。但是，有太多不同的系统假设快速追加索引，因此GNU ar实现了q作为r的同义词。
r  # 将文件‘member’插入到归档文件，如果归档中存在要插入的文件，那么就覆盖。此操作与q的不同之处在于，如果现有成员的名称与要添加的成员匹配，则删除它们。如果成员中不存在‘member’，ar显示错误消息，并保持与该名称匹配的任何现有存档成员不受干扰。默认情况下，在文件末尾添加新成员；但您可以使用其中一个修饰符a、b或i请求相对于现有成员的位置。与此操作一起使用的修饰符v将引发插入的每个文件的一行输出。字母a或r，以指示文件是否被追加(没有删除旧成员)或被替换。
t  # 显示归档文件包含的文件列表。通常只显示成员名称；如果还希望查看模式(权限)、时间戳、所有者、组和大小，则还可以通过指定v修饰符来请求。如果未指定成员，则将列出存档中的所有文件。如果一个存档中有多个同名文件，只列出第一个实例；要查看它们，您必须要求一个完整的列表。
x  # 从归档文件中提取成员文件，您可以在此操作中使用v修饰符，在提取时请求ar列出每个名称。如果不指定成员，则提取存档中的所有文件。无法从瘦存档中提取文件。
```
许多修饰符(Mod)可以紧跟p键，以指定操作行为的变化
``` bash
a  # 在存档的现有成员之后添加新文件。如果使用修饰符a，则现有存档成员的名称必须作为relpos参数出现在归档规范之前。
b  # 在存档的现有成员之前添加新文件。如果使用修饰符b，则现有存档成员的名称必须作为relpos参数出现在归档规范之前。(与i相同)
c  # 创建档案。当您请求更新时，如果指定的存档不存在，则始终创建它。但是，除非事先指定通过使用此修饰符来创建警告，否则将发出警告。
D  # 在确定性模式下操作。当添加文件和存档索引时，对UID、GID、时间戳使用零，并对所有文件使用一致的文件模式。当使用此选项时，如果ar与相同的选项和相同的输入文件一起使用，则多次运行将创建相同的输出文件，而不管输入文件的所有者、组、文件模式或修改时间。
f  # 截断存档中的名称。GNU ar通常允许任意长度的文件名。这将导致它创建与某些系统上的本机ar程序不兼容的档案。如果这是个问题，那么当将f修饰符放在归档文件中时，可以使用f修饰符来截断文件名。
i  # 在存档的现有成员之前插入新文件。如果使用修饰符i，则现有存档成员的名称必须作为relpos参数出现在归档规范之前。(与b相同)
l  # 没有用的修饰符
N  # 使用计数参数。如果存档中有多个具有相同名称的条目，则使用此方法。从存档中提取或删除给定名称的实例计数
o  # 提取成员时保留成员的原始日期。如果不指定此修饰符，则从档案中提取的文件将加盖提取时间。
P  # 在存档中匹配名称时使用完整路径名称。GNU ar不能创建具有完整路径名的存档(这类档案不是POSIX投诉)，但其他归档创建者可以。此选项将导致GNU ar使用完整的路径名匹配文件名，这在从另一个工具创建的归档文件中提取单个文件时非常方便。
s  # 将对象文件索引写入存档，或更新现有的索引，即使没有对归档进行其他更改。您可以在任何操作中使用此修饰符标志，也可以单独使用。在存档上运行ar等于在它上运行ranlib。
S  # 不要生成存档符号表。这可以加快构建一个大型库的几个步骤。结果存档不能与链接器一起使用。为了构建符号表，必须在ar的最后一次执行时省略S修饰符，或者必须在归档文件上运行ranlib。
T  # 将指定的归档文件设置为瘦存档。如果它已经存在并且是一个常规存档，则现有成员必须与存档目录相同。
u  # 通常，ar r将列出的所有文件插入存档中。如果只想插入比同名的现有成员更新的文件，请使用此修饰符。u修饰符仅允许用于操作r(替换)。特别是不允许使用组合qu，因为检查时间戳将失去操作q的任何速度优势。
v  # 显示详细执行过程
V  # 显示ar的版本
```
AR忽略初始选项-x32_64，以便与AIX兼容。此选项产生的行为是GNU ar的默认行为。ar不支持任何其他-X选项；特别是，它不支持-x32，这是AIX ar的默认设置。

可选的命令行开关“--plugin name”使ar加载名为name的插件，这增加了对更多文件格式的支持。只有在工具链已启用插件支持的情况下，此选项才可用。

@file选项，从文件中读取命令行选项。已读取的选项被插入以代替原始的@file选项。如果文件不存在或无法读取，则将按字面处理该选项，而不删除该选项。file中的选项用空格分隔。可以在选项中包含空格字符，方法是将整个选项包围在单引号或双引号中。任何字符(包括反斜杠)都可以通过前缀所包含的字符来包括在反斜杠中。file本身可能包含额外的@file选项；任何此类选项都将被递归处理。

```
--plugin <p> - load the specified plugin
```
ar：支持的目标： elf64-x86-64 elf32-i386 elf32-x86-64 a.out-i386-linux pei-i386 pei-x86-64 elf64-l1om elf64-k1om elf64-little elf64-big elf32-little elf32-big plugin srec symbolsrec verilog tekhex binary ihex
## 举例

``` bash
创建归档文件
[sogrey@bogon newDir3]$ ll
总用量 16
-rw-------. 1 sogrey sogrey  38 1月  27 23:42 1.txt
-rw-------. 1 sogrey sogrey  62 1月  24 01:03 students.txt
-rw-------. 1 sogrey sogrey  11 1月  24 01:08 test2.txt
-rw-------. 1 sogrey sogrey 135 1月  24 01:05 test.txt
[sogrey@bogon newDir3]$ ar -rc mlib.a test.txt test2.txt # 创建归档
[sogrey@bogon newDir3]$ ls
1.txt  mlib.a  students.txt  test2.txt  test.txt
[sogrey@bogon newDir3]$ ar -t mlib.a # 查看归档的文件列表
test.txt
test2.txt
[sogrey@bogon newDir3]$ 
```
在归档中插入文件
``` bash
[sogrey@bogon newDir3]$ ar -rc mlib.a 1.txt # 插入1.txt，此时归档中还没有1.txt
[sogrey@bogon newDir3]$ ar -t mlib.a
test.txt
test2.txt
1.txt
[sogrey@bogon newDir3]$ 
```
在归档的最后插入文件
``` bash
[sogrey@bogon newDir3]$ ar -q mlib.a students.txt # 是用选项q来追加到最后，注意这个和r是不一样的
[sogrey@bogon newDir3]$ ar -t mlib.a
test.txt
test2.txt
1.txt
students.txt
[sogrey@bogon newDir3]$ 
```
从归档中删除文件,只删除第一个
``` bash
[sogrey@bogon newDir3]$ ar -d mlib.a students.txt
[sogrey@bogon newDir3]$ ar -t mlib.a
test.txt
test2.txt
1.txt
[sogrey@bogon newDir3]$ 
```