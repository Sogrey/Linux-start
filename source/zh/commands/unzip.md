# unzip - 用于解压缩由zip命令压缩的压缩包
unzip命令 用于解压缩由zip命令压缩的“.zip”压缩包。

解压zip指令压缩过的文件。unzip将列出、测试或从ZIP存档中提取文件，这些文件通常在MS-DOS系统中找到。默认行为(没有选项)是将指定ZIP存档中的所有文件提取到当前目录(及其下面的子目录)中。一个配套程序zip(1L)创建ZIP档案；这两个程序都与PKWare的PKZIP和PKUNZIP为MS-DOS创建的档案兼容，但在许多情况下，程序选项或默认行为有所不同。

## 适用范围

<!-- <div class="svg linux">Linux</div> -->
<div class="svg redhat">RedHat</div>
<div class="svg rhel">RHEL</div>
<div class="svg ubuntu">Ubuntu</div>
<div class="svg centos">CentOS</div>
<div class="svg debian">Debian</div>
<div class="svg deepin">Deepin</div>
<div class="svg suse">SUSE</div>
<div class="svg opensuse">openSUSE</div>
<div class="svg fedora">Fedora</div>
<div class="svg linuxmint">Linux Mint</div>
<!-- <div class="svg mxlinux">MX Linux</div> -->
<div class="svg alpinelinux">Alpine Linux</div>
<div class="svg archlinux">Arch Linux</div>

## 语法

``` bash
unzip  [-Z]  [-cflptTuvz[abjnoqsCDKLMUVWX$/:^]]  file[.zip]  [file(s) ...]  [-x xfile(s) ...]  [-d exdir]
```

## 选项

``` bash
file[.zip]        # ZIP存档的路径。如果文件规范是通配符，则按操作系统(或文件系统)确定的顺序处理每个匹配的文件。只有文件名可以是通配符；路径本身不能。通配符表达式类似于常用Unix shell(sh、ksh、csh)中支持的表达式，可能包含：
                  # *，匹配0或多个字符的序列。
                  # ？，匹配一个字符。
                  # […]，匹配括号内的任何单个字符；范围由开始字符、连字符和结束字符指定。如果是感叹号或插入符号(‘！‘或者‘^’)在左括号后面，则括号中的字符范围被补充(也就是说，除了括号中的字符外，任何字符都被认为是匹配的)。若要指定逐字左括号，必须使用三个字符序列‘‘[[]’’。
                  # (确保引用任何可能被操作系统解释或修改的字符，特别是在Unix和VMS下。)如果没有找到匹配项，则假定规范为文字文件名；如果也失败，则追加后缀.zip。请注意，与任何其他ZIP存档一样，支持自解压ZIP文件；只需显式地指定.exe后缀(如果有的话)。

[file(s)]         # 要处理的归档成员的可选列表，用空格分隔。(用VMSCLI定义的VMS版本必须用逗号分隔文件。见下文备选案文中的-v)。正则表达式(通配符)可用于匹配多个成员；参见上文。同样，请务必引用否则将由操作系统展开或修改的表达式

[-x xfile(s)]     # 要排除在处理之外的归档成员的可选列表。由于通配符通常匹配(‘/’)目录分隔符(异常请参见选项-W)，此选项可用于排除子目录中的任何文件。例如，“unzip  foo  *.[Ch]  -x  */*”将提取主目录中的所有C源文件，但在任何子目录中都不提取。如果没有-x选项，则将提取zip文件中所有目录中的所有C源文件。

[-d exdir]        # 提取文件的可选目录。默认情况下，所有文件和子目录都在当前目录中重新创建；-d选项允许在任意目录中提取(总是假定一个目录具有写入该目录的权限)。这个选项不需要出现在命令行的末尾；它也可以在zipfile规范之前(带常规选项)、在zip文件规范之后，或者在文件和-x选项之间被接受。选项和目录可以连接在一起，没有任何空白，但请注意，这可能会导致正常的shell行为被抑制。特别是，‘-d~’被Unix C shell扩展为用户主目录的名称，但是‘-d~’被视为当前目录的一个文字子目录‘~’。
```
请注意，为了支持过时的硬件，Unzip的使用屏幕仅限于22或23行，因此只应被视为基本解压缩语法的提醒，而不是所有可能的标志的详尽列表。详尽的清单如下：
``` bash
-c                # 将解压结果送到标准输出
-f                # 解压时更新现有的文件,即仅解压磁盘上已经存在且比磁盘副本更新的文件。默认情况下，在覆盖之前解压缩查询，但是-o选项可以用于抑制查询
-l                # 显示压缩包内文件的详细信息。将打印指定文件的名称、未压缩文件大小、修改日期和时间，以及所有指定文件的总计。
-p                # 将解压结果送到标准输出，不对字符转换。只有文件数据被发送到stdout，文件总是以二进制格式提取
-t                # 检查压缩文件的正确性。该选项提取内存中的每个指定文件，并将扩展文件的CRC(循环冗余校验，增强校验和)与原始文件的存储CRC值进行比较。
-T                # 将存档上的时间戳设置为每个归档中最新文件的时间戳。这对应于zip的-go选项，但它可以用于通配符zip文件(例如，“unzip –T \*.zip”)，而且速度要快得多
-u                # 更新现有文件，并在需要时创建新文件。该选项执行与-f选项相同的功能
-v                # 列出存档文件(详细格式)或显示诊断版本信息。
-z                # 仅显示压缩文件的备注信息

-a                # 解压时，对文本文件做字符转换
-b                # 不对文本文件字符转换，把所有文件当做二进制文件。
-B                # 保存每个覆盖文件的备份副本，‘foo’的旧拷贝改名为‘foo~’。
-C                # 解压时，设置文件名大小写敏感
-D                # 跳过提取项的时间戳恢复。
-E                # [仅限MacOS]在恢复操作期间显示MacOS额外字段的内容。
-F                # [仅限Acorn]禁止从存储的文件名中删除NFS文件类型扩展。
-i                # [仅限MacOS]忽略存储在MacOS额外字段中的文件名。相反，使用存储在条目标题的泛型部分中的最兼容的文件名。
-j                # 垃圾路。存档的目录结构不被重新创建；所有文件都存放在提取目录中(默认情况下是当前的)。
-J                # [仅限BeOS]垃圾文件属性。文件的BeOS文件属性没有恢复，只是文件的数据。
-K                # 保留SUID/SGID/duy文件属性。如果没有此标志，则出于安全原因，将清除这些属性位。
-L                # 解压时，将文件名改为小写字母
-M                # 把解压结果送给more分屏显示
-n                # 解压时，不覆盖原有的文件
-N                # 将文件注释解压缩为Amiga文件。
-o                # 不提示用户，覆盖原有文件
-P                # 解压时，输入密码
-q                # 静默模式
-s                # [OS/2,  NT,  MS-DOS]将文件名中的空格转换为下划线
-S                # [VMS]将文本文件(-a，-aa)转换为Stream_LF记录格式，而不是文本文件默认的可变长度记录格式。
-U                # [UNICODE_SUPPORT only] 修改或禁用UTF-8处理。当Unicode_Support可用时，选项-U强制解压将UTF-8编码文件名中的所有非ASCII字符转义为“#Uxxxx”
-V                # 保留(VMS)文件版本号。VMS文件可以用版本号存储，格式为file.ext；#。默认情况下，‘；#’版本号将被删除，但此选项允许保留它们。
-W                # [仅当WILD_STOP_AT_DIRR编译时选项启用] 修改模式匹配例程，以便 “？”和“*”与目录分隔符“/”不匹配。
-X                # [VMS,  Unix,  OS/2,  NT,  Tandem] 在Unix下恢复用户和组信息(UID/GID)
-Y                # [VMS] 将存档的文件名结尾“.nn”(其中‘nnn’是一个十进制数)视为VMS版本号(‘；nnn’)。(默认的做法是将它们视为文件类型。)
-$                # [MS-DOS, OS/2, NT]如果提取介质是可移动的(例如磁盘)，则恢复卷标签。加倍的选项($-$)允许固定媒体(硬盘)也被标记。默认情况下，卷标签将被忽略。
-/ extensions     # [Acorn] 重写Unzip$Ext环境变量提供的扩展列表。在提取过程中，与此扩展列表中的项匹配的文件名扩展名将在提取文件的基名前面交换。
-:                # 允许将存档成员解压缩到当前“提取根文件夹”之外的位置。
-^                # [Unix only] 允许提取的ZIP存档条目的名称中包含控制字符。
-2                # [vms]强制无条件地将文件名转换为ODS 2-兼容名称

--help            # 显示帮助文档
--version         # 显示命令版本信息
```

## 环境选项

unzip的默认行为可以通过放置在环境变量中的选项来修改。这可以用任何选项来完成，但是它可能对-a，-L，-C，-q，-o或-n修饰符最有用：默认情况下使unzip自动转换文本文件，使文件名从大写系统转换为小写，使其不敏感地匹配名称，使其更安静，或者让它在解压文件时始终覆盖或不覆盖它们。例如，要使解压缩尽可能安静，只报告错误，可以使用以下命令之一：
``` bash
Unix Bourne shell:      UNZIP=-qq; export UNZIP
Unix C shell:setenv       UNZIP -qq
OS/2 or MS-DOS:set       UNZIP=-qq
VMS (quotes for lowercase):      define UNZIP_OPTS "-qq"
```
实际上，环境选项被认为与任何其他命令行选项一样，只是它们实际上是命令行中的第一个选项。要覆盖环境选项，可以使用“减号运算符”来删除它。例如，若要覆盖上面示例中的一个静音标志，请使用以下命令
``` bash
unzip --q[other options] zipfile
```
第一个连字符是正常的开关字符，第二个是负号，作用于Q选项。因此，这里的效果是取消一个安静的量子。若要取消这两个安静的标志，可以使用两个(或更多)最小值：
``` bash
unzip -t--q zipfile
unzip ---qt zipfile              # 这两个是等价的
```
正如上面的例子所建议的，默认变量名是UNZIP_OPTS，用于VMS，以及所有其他操作系统的解压缩。为了与zip(1L)兼容，UNZIP_OPTS也被接受(不要问)。但是，如果同时定义了UNZIP和UNZIP_OPTS，那么UNZIP优先。Unzip的诊断选项(没有zip文件名的-v)可以用于检查所有四个可能的解压缩和zipinfo环境变量的值

## 说明

unzip的某些编译版本可能不支持解密。若要检查加密支持版本，可以尝试测试或提取加密存档，或者检查unzip的诊断屏幕(请参阅上面的-v选项)以“[解密]”作为特殊的编译选项之一。

如上所述，可以使用-P选项在命令行上提供密码，但代价是安全性。首选的解密方法是正常提取；如果zip文件成员被加密，解压缩将提示输入密码，而不回显所键入的内容。解压缩继续使用相同的密码，只要它看起来是有效的，通过在每个文件上测试一个12字节的头。正确的密码将始终签出与标题，但有1/256的机会，一个不正确的密码也会。(这是PKWare zipfile格式的一个安全特性；它有助于防止暴力攻击，否则只通过测试报头就可以获得很大的速度优势。)如果给出了错误的密码，但它还是通过了头测试，则将为提取的数据生成不正确的CRC，或者在提取过程中解压缩失败，因为‘解密’字节并不构成有效的压缩数据流。

如果第一个密码没有通过头检查某个文件，解压缩将提示输入另一个密码，以此类推，直到提取所有文件。如果不知道密码，则输入空密码(即只返回一个回车或‘Enter’)作为跳过所有进一步提示的信号。随后将只提取存档中未加密的文件。(事实上，这并不完全正确；早期版本的zip(1L)和zipcloak(1L)允许空密码，因此解压缩检查每个加密文件以查看空密码是否有效。这可能会导致“假阳性”和提取错误，如上所述。)

用8位密码加密的档案(例如，带有重音的欧洲字符的密码)可能无法跨系统和/或其他存档器移植。这个问题源于对这些字符使用多种编码方法，包括拉丁文1(ISO 8859-1)和OEM代码页850。DoS PKZIP 2.04g使用OEM代码页；Windows PKZIP 2.50使用拉丁文-1(因此与DOS PKZIP不兼容)；Info-ZIP使用DOS、OS/2和Win3.x端口上的OEM代码页，但使用ISO编码(拉丁文-1等)。在其他地方，NicoMak的WinZip6.x根本不允许8位密码。解压缩5.3(或更新)尝试首先使用默认字符集(例如拉丁语-1)，然后使用备用字符集(例如OEM代码页)测试密码。

## 举例

``` bash
unzip  letters
# 将letters.zip解压到当前的目录以及其子目录下

unzip  -j  letters
# 将letters.zip解压到当前目录下

unzip  -tq  letters
# 测试letters.zip，打印出测试信息，确定压缩包是否完整

unzip  -tq  \*.zip
# 测试当前目录下的所有zip文件，打印总和信息

unzip  -ca  letters  \*.tex  |  more
# 要将名称以.tex结尾的letters.zip的所有成员提取为标准输出，自动转换为本地行尾约定，并将输出传递给more程序

unzip  -p  articles  paper1.dvi  |  dvips
# 将二进制文件解压到标准输出，并且通过管道送到另一个打印程序

unzip  source.zip  "*.[fch]"  Makefile  -d  /tmp
# 将所有的c语言和FORTRAN语言的源文件，以及Makefile解压到/tmp目录

unzip  -C  source.zip  "*.[fch]"  makefile  –d  /tmp
# 将所有的c语言和FORTRAN语言的源文件，以及Makefile解压到/tmp目录（忽略所有的大小写）

unzip  -aaCL  source.zip  "*.[fch]"  makefile  –d  /tmp
# 提取任何此类文件，但将ms-dos或vms中任何大写名称转换为小写，并将所有文件的行尾转换为本地标准。

unzip  -fo  sources
# 仅提取当前目录中已经存在的较新版本的文件，而不进行查询

unzip  -uo  sources
# 提取当前目录中已存在的较新版本的文件，并创建尚未存在的任何文件。

unzip  –v
# 要显示诊断屏幕，显示哪些解压缩和zipinfo选项存储在环境变量中，是否在环境变量中编译解密支持，以及编译解压缩的编译器等等

unzip  -l  file.zip
# 只是列出内容

unzip  -ql  file.zip
# 双倍安静的列表

unzip  --ql  file.zip
unzip  -l-q  file.zip
unzip  -l--q  file.zip
# 标准的列表
```
显示备注信息
``` bash
[sogrey@bogon 文档]$ zip 1.zip 1.c            # 压缩
  adding: 1.c (deflated 9%)
[sogrey@bogon 文档]$ unzip -z 1.zip           # 显示备注
Archive:  1.zip
```
显示压缩包内的文件信息
``` bash
[sogrey@bogon 文档]$ unzip -l 1.zip
Archive:  1.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
       53  09-19-2018 16:08   1.c
---------                     -------
       53                     1 file
```
解压
``` bash
[sogrey@bogon 文档]$ unzip -n -v 1.zip      # 显示解压过程
Archive:  1.zip
 Length   Method    Size  Cmpr    Date    Time   CRC-32   Name
--------  ------  ------- ---- ---------- ----- --------  ----
      53  Defl:N       48   9% 09-19-2018 16:08 1c3e46be  1.c
--------          -------  ---                            -------
      53               48   9%                            1 file
```

## 诊断信息

退出码说明

- 0 正常，没有错误信息
- 1 遇到一个或多个警告错误，但仍然成功地完成了处理。这包括由于不支持的压缩方法或密码未知的加密而跳过一个或多个文件的zip文件。
- 2 检测到zip文件格式中的通用错误。无论如何，处理可能已经成功完成；一些由其他归档程序创建的损坏的zip文件具有简单的工作环境。
- 3 检测到zip文件格式出现严重错误。处理可能立即失败
- 4 在程序初始化期间，unzip无法为一个或多个缓冲区分配内存。
- 5 unzip无法分配内存，也无法获取TTY来读取解密密码。
- 6 unzip过程中无法将内存分配给磁盘。
- 7 unzip无法在内存解压缩期间分配内存.
- 8 当前还没有用到这个退出码
- 9 指定的压缩文件没有找到
- 10 非法的选项
- 11 找不到匹配的文件
- 50 磁盘已经满了
- 51 ZIP存档的结尾是过早地遇到的。
- 80 用户使用ctrl+c终止了解压过程
- 81 由于不支持的压缩方法或不支持的解密，一个或多个文件的测试或提取失败
- 82 由于解密密码错误，没有找到任何文件。(但是，即使成功处理了一个文件，退出状态也是1。)